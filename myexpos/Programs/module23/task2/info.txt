In this module we will add support for file creation and deletion

______________________________________________________________________________________________________________
eXpOS file system - eXpFS
==============================================================================================================
eXpFS file system comprises of files organised in a single directory called root directory.
The root is also treated as a file. Every file is a sequence of bytes and has three attributes -
name, type and size (each one word long). Each file name is a unique string. Size is the total
number of words stored in the file.
There are three types of file - root, data and executable. Each file has an entry in the root.

Root File -
    root contains tha metadata of the files stored in the file system. Name, size and type of each
    file is stored - this is called the root entry of the file. The first root entry is the root
    itself. The operation on the root file are open, close, read and seek.

Data File -
    data files contains sequence of words with max size MAX_FILE_SIZE. Any file other than root and
    executable is treated as datafile. Any file created through Create syscall automatically gets the
    type DATA (by the syscall). The operation allowed are create, delete, open, close, read, write,
    seek. Data files can either be created using Create syscall or loaded using xfs-interface.

Executable File -
    executable files have type EXEC and are not allowed to be created by the application programs. They
    can be created externally and loaded using xfs-interface. The executable files must be in the
    executable file format.


When a data file is created using Create syscall, the owner may set its permission to exclusive (0) /
open-access (1). When the access is restricted, no other "user" except the owner can write/delete
the file (using syscalls). Irrespective of the permission, the root can delete/modify any data file
(but not root file or an execuatble file). The root file has userid set to 0 (kernel) and permission
as exclusive (0).
The owner of any executable file is set to kernel (0) and file access permission are not used for
executable files. Any data file loaded externally has owner as kernel (0) and permission to open access.


NOTE - the files generated by the compiler are in format that is dependent both on the OS and the target
    machine.


______________________________________________________________________________________________________________
Disk Free List
==============================================================================================================
Disk Free List is a data structure that specifies whether a disk block is free or allocated.

Disk blocks are allocated for a file by Write syscall. Disk block are allocated when file is
removed using Delete syscall. The disk free list is updated accordingly. (GetFreeBlock and ReleaseBlock
in the memory manager module) are used to allocate blocks and release them.

______________________________________________________________________________________________________________
Inode table and Root file
==============================================================================================================
Inode table and root file stores meta data of the files present in the system.
Inode table is present in page number 59 (INODE_TABLE).
Root file is present in page 62 (ROOT_FILE).

Inode table contains an entry for each file in the file system. An inode entry is created for a file
when it is created using Create syscall or loaded using xfs-interface. An entry in the inode table stores -
filename, filesize, "userid" (of owner), type, access permission, block numbers (max 4 blocks).
A Create syscall doesn't allocate blocks for a file but just creates an inode entry for it. Size is
initially 0. The filename and access permiission are provided along with the syscall. File created will
have type DATA. When a block is allocated to a file during Write syscall the inode table is updated to
record the block. The userid is set to the currently logged in user.

Reference - http://exposnitc.github.io/os_design-files/disk_ds.html#inode_table


Root file stores information in user readable format. There is no hierarchial file system and all the
files are at the same level. The kth entry corresponds to the file at kth entry in the inode table.
Root file contains filename, size, type, "username", permission. Thus the part of the inode table is
duplicated in the root file. The only difference is that the root file can be read by the user programs
using Read syscall whereas the inode table is exclusive to the OS.
Write and Delete operations are not permitted on root file.
The only info that is present in the root file but not the inode table is the username (of owner).
Inode table contains the userid, which can be used to look into the user table to find the username.
When a file is created using Create syscall, the entries in the root file must be created (along with the
inode table entry). Similarly when the file is edited using Write syscall, its size must also be updated.

Reference - http://exposnitc.github.io/os_design-files/disk_ds.html#root_file

______________________________________________________________________________________________________________
User table
==============================================================================================================
User table consists of username and encrypted password for each user in the system. The userid of
a user is its user table index. When file is created, the Create syscall can look up in the
process table of the current process to find the user id and sets its value in the inode table.
It then looks up in the user table and gets the username and sets its corresponding value in
the root file.
When the XFS-disk is formatted two users - kernel and root are automatically created.

Reference - http://exposnitc.github.io/os_design-files/disk_ds.html#user_table





NOTE - The above data structures are called disk data structure. Because even when the system
is shutdown, their copy is present in the disk. The below data structure are transient - in memory
data structures, which means they remain as long as the machine is running. They are lost when the
machine shuts and are no longer relevant.



Each time when a file is opened by same/different process using open syscall a different open instance
for the file is created. The OS keeps track of the number of open instances at any time. Each open
instance has a seek pointer which points to a particular location in the file. Whenever, the file is
read from or written into the seek pointer is update to point to the new position.
When a process forks the seek pointer is shared by the parent and the child. So, if any performs read/
write the seek pointer for both of them is updated. The seek pointer can also be updated using
Seek syscall.

When a process tries to close an open instance using Close syscall, the OS checks if some other process
is sharing the open instance. If so, just the corresponding count field is decremented. When the count
reaches 0, the open instance is removed.

To implement this the OS implements the file status table (inode status table) and open file table. Also,
for eahc file there is also per-process resource table, which contains info for the open instances of
a particular file.

Finally there is buffer cache for caching the data files of files currently in use. And buffer table is
used to manage data related to buffer cache.

______________________________________________________________________________________________________________
Open File Table
==============================================================================================================
It stores the info of all the files that are opened while the OS is running. It contains MAX_OPENFILE_NUM
entries (= 32). It is stored in the memory page 56 and constant OPEN_FILE_TABLE points to this location.

Open syscall creates an entry into the open file table. When a file is opened again (either by the same or
a different process) a new entry is created.
Each entry is of 4 words of which the last is unused. The entries are -
    inode index, open instance count, LSEEK

Special inode index - INODE_ROOT is used for the root file.
The count stores the number of processes sharing this open instance.
LSEEK specifies the next position from which the read or write is done.

All invalid entries are set to -1.
An entry of -1 in the inode index indicates invalid entry.

Reference - http://exposnitc.github.io/os_design-files/mem_ds.html


______________________________________________________________________________________________________________
File Status Table
==============================================================================================================
File status table contains MAX_FILE_NUM (= 60) entries. It contains an entry corresponding to each file
in the inode table (their index must match). It is stored in the memory page 57 and the constant
FILE_STATUS_TABLE points to its beginning.

It stores the following field corresponding to each file
    Locking PID - This field specifies the PID of the process, that has locked the file in a syscall.
                        If no such process then -1 is stored.
    File Open Count - Number of open instances of a file. Set to -1 if no open instance for the file
                        exists.

Each entry is of four words out of which last two are unused.

It serves two purposes - count of how many process has opened the file
                       - a mechanism to lock the file before making update to its data/metadata

AcquireInode and ReleaseInode functions of the resource manager module are used to implement file
related regulations.


Reference - http://exposnitc.github.io/os_design-files/mem_ds.html#file_lock_status_table
          - http://exposnitc.github.io/Tutorials/filesystem_implementation.html


______________________________________________________________________________________________________________
Per-process resource table
==============================================================================================================
The perprocess resource table is stored in the last 16 entries of the user area page. It stores the
info about the files and semaphores being used by a process. Each entry contains two fields -
    the first entry denotes whether the entry is for a file or a semaphore (an invalid entry is
    denoted by -1).
    the second entry is the corresponding index in the semaphore table/open file table.

Open syscall returns the index in the resource table of the open instance to be used as open file descriptor.

Reference - http://exposnitc.github.io/Tutorials/filesystem_implementation.html


______________________________________________________________________________________________________________
Memory Buffer Cache
==============================================================================================================
Whenever a process tries to read/write into a file, the corresponding block is first brought into
the buffer cache in the memory and then the corresponding read/write is performed on the copy of the
block stored in the buffer. eXpOS maintains four memory pages as buffer cache (71 - 74), lets call 0 - 4.
The i block in the disk will be loaded in the (i mod 4) buffer. If there is some data already in the
buffer and it needs write back (dirty bit is set) then the corresponding block is written and then
the requested block is loaded in the buffer cache.


______________________________________________________________________________________________________________
Buffer Table
==============================================================================================================
Buffer Table is used for managing the buffer cache.
It contains an entry for each of the four buffer caches. An entry consists of the following fields -
    - block number of block loaded in the buffer. If no block is currently loaded, the entry is -1.
    - Dirty bit (indicating whether the block was modified)
    - PID of the process that has locked the buffer page (-1 if no page has locked the buffer)
        The locking PID is used so that no two processes concurrently try to load blocks into the
        buffer.


Read the example of the dynamics given in the last section of the following link
Reference - http://exposnitc.github.io/Tutorials/filesystem_implementation.html



The execution of ​Read/Write​ system calls involves a sequence of resource acquisitions - namely inode,
buffer and disk. The resources are acquired in the order Inode-buffer-disk and must be released in
the reverse order when the actions are completed. This avoids circular wait - a sufficient condition
for deadlock prevention.


Also, the OS keeps the copy of these data structures in the memory. Any updates are made in the memory
copy only. So, when the system shuts down, these data structures must also be updated in the disk (if any
copy exists).
