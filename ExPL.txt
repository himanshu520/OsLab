ExpL permits application programs to call the function exposcall() that implements the high level library interface
to the OS. Application programs must use this library interface to invoke eXpOS system calls. Certain built-in functions
of the ExpL language (Alloc, Free and Initialize - these functions handle ExpL dynamic memory management) are also
implemented as ExpL library routines.

The ExpL library file library.lib, contains assembly language implementation of the library and occupies two pages
of memory. The library code must be pre-loaded to the XSM disk blocks 13 and 14 before OS bootstrap using XFS interface.
The OS start up code is supposed to load this code into memory pages 63 and 64 from disk blocks 13 and 14.

The compiler expects that the library will be loaded to the logical address 0 of the address space of the program.
The target code generated by the compiler will not contain the code for the library. Instead, the OS is expected to
link this code (at physical pages 63 and 64) into logical pages 0 and 1 when the program is loaded for execution.
The library linkage must be done correctly for an eXPL program to run.


________________________________________________________________________________________________________________________________
eXPL
================================================================================================================================
Datatypes -
    primitive data types
        int, str - has only alphanumeric characters
        booleans are not supported but logical expressions are considered to be of boolean type
    composite data types
        array of int, str -
            only single dimesional
            are statically linked
            only global declaration allowed
        user defined datatypes
            similar to structures
            member fields can be of int, str, previously defined type, or of type currently being defined
            memory to user defined datatypes must be dynamically allocated/freed using alloc()/free()
            user defined datatypes take default value of NULL unless assigned or dynamically allocated
            Example -
                    mytype{ int a; str b; }
                    mytype x, y;
                    x = alloc();
                    x.a = 10;       /* members are accessed using '.' operator */

Program structure -
    derived datatypes declarations -
        all user defined datatypes must be declared in the type definition section - type ... endtype
    global decalarations -
        variables, functions, arrays are declared
        all declarations must be made within - decl ... enddecl - section
        static allocation of global variables take place
        visible throughout the program unless suppressed by local redeclaration within some function
        can't assign values during declaration
        function declaration -
            all the functions except main() must be declared
            declaration must give the function name, argument name and types, and the type of the return value
            function can have int, str, or user defined types as argument
            return type can also be int, str, user defined types
            call be value is used for int and str,  and call by reference for user defined data types
            arrays can't be passed as arguments
            declaring functions at the beginning solves the forward reference problem - enabling one pass compilation
        we can combine the declaration of the variables/function of the same type
        Example -
                int x, y, fact(int a);
                str firstname, secondname, fullname(str fn, str sn);
    function definitions and main() definition -
        function definition is similar to C, however the definition header must match exactly with the declaration
        arrays and functions can't be declared inside functions
        local variables are declared inside - decl ... enddecl block
        main() must be zero argument function with return type int
        the body of a function must be declared within begin ... end block
        functions should have only one return statement and that must be the last statement inside the function
        the language supports recursion

Statements and expressions -
    Constants -
        integer constants
        string constants - only alphanumeric characters
        special value NULL of type void
    Arithematic and string expression -
        any int (str) constant is an integer (string) expression
        function returning int (str) are also valid integer (string) expression
        integer expressions can be combined using arithematic operators
        eXPL is strongly typed, so type mismatch is reported at compiletime
    Logical expressions -
        arithematic expressions may be combined using relational operators
        we can combine logical expressions using and/or/not
        relational operators can also be applied to strings - lexicographic ordering is used
        variables of user defined datatypes can only be checked for equality using ==, !=
    expressions for user-defined datatypes
        any variable of user-defined type
        any function whose return type is of user-defined type
    Assignment statement
        general statement of the type Lvalue = Rvalue
        Lvalue can be int/str - then the Rvalue must be int/str expression
        if Lvalue is user-defined type then Rvalue must be corresponding expression or NULL or alloc()
        for user defined datatypes the assignment is not of the values but of the pointers to the actual object
    Conditional statement
        syntax - if <logical expr> then <statement> else <statement> endif;
        the else part is optional
        statement can be any statement except return statement
    Iterative
        syntax - while <logical expr> do <statement> endwhile;
        again statement can be anything except the return statement
    Return statement -
        for return type of user-defined types, we can even return NULL
    I/O statement -
        syntax -  read(<int/str variable>);
        syntax - write(<int/str variable/expression);
    Jump statement -
        break can be used inside iterative block
        continue can be used inside an iterative/conditional block
    Breakpoint statement -
        statement - breakpoint;

Dynamic memory allocation
    Three functions are used for dynamic memory allocation -
        initialize() - for initializing the heap to default values -  must be called once before dynamic allocation
        alloc() -  assigns contiguous memory location from the heap and returns the starting address of the allocated area
                    the current implementation in eXpOS allocates 8 words irrespective of the size required for allocation
                    so don't declare a user defined type with more than 8-fields
        free(<arg>) - used to reclaim the dynamically allocated area - returns NULL on success, and arg stores NULL otherwise
                        remains unchanged.

Identifiers -
    The naming convention for identifiers follows following convention -
        a = {a, b, ..., z, A, B, ..., Z}
        d = {0, 1, ..., 9}
        Identifier = a (a + d)*



________________________________________________________________________________________________________________________________
exposcall() - eXpOS library interface function
================================================================================================================================
ExPL compiler provided with the eXpOS package extends the language by providing the exposcall() function
ExPL programs can invoke eXpOS syscalls  and dynamic memory allocation routines by passing appropriate arguments

High Level Library Interface is a unified Application Programming Interface (API) to access system call routines
and dynamic memory management functions from application programs.

The general syntax for exposcall is -
        t = exposcall(fun_code, arg1, arg2, arg3);
